################################################################################
# simple.qos (Cero3 Shaper)
#
# Abstract:
# This is a multi-band HFSC based shaping script for Ethernet
# gateways. It's based on custom shapers created by Daniel Lakeland for his own use
# it allows realtime priority for certain traffic and then has 4 bands for
# non-realtime traffic
################################################################################
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License version 2 as
# published by the Free Software Foundation.
#
#  Copyright (C) 2012-2016
#    Michael D. Taht, Toke Høiland-Jørgensen, Sebastian Moeller, Daniel Lakeland
#
################################################################################

. ${SQM_LIB_DIR}/defaults.sh

################################################################################

ipt_setup() {

    ipt -t mangle -N QOS_MARK_${IFACE}

    case $QDISC in
        cake*)
            sqm_debug "cake does all the diffserv work - no need for iptables rules"
            ;;
        *)

            # You can go further with classification but...
            ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS1 -j CLASSIFY --set-class 1:6
            ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS2 -j CLASSIFY --set-class 1:5
            ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS0 -j CLASSIFY --set-class 1:4
            ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS3 -j CLASSIFY --set-class 1:4
            ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS4 -j CLASSIFY --set-class 1:3
            ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class AF41 -j CLASSIFY --set-class 1:3	    
            ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS5 -j CLASSIFY --set-class 1:2
            ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS6 -j CLASSIFY --set-class 1:2
            ipt -t mangle -A QOS_MARK_${IFACE} -m dscp --dscp-class CS7 -j CLASSIFY --set-class 1:2
            ;;
    esac

    # Turn it on. Preserve classification if already performed
    #
    #sm: is it correct to do this in $IFACE? Should ingress not be on $DEV? since HTB acts on $DEV?
    #
    # ZERO also does not work on $DEV (that is the IFB will still see the
    # incoming ToS bits whether we squash or not)
    #
    # ZERO is still useful to protect internal machines...
    if [ "$ZERO_DSCP_INGRESS" = "1" ]; then
        sqm_debug "Squashing differentiated services code points (DSCP) from ingress."
        ipt -t mangle -I PREROUTING -i $IFACE -m dscp ! --dscp 0 -j DSCP --set-dscp-class be
    else
        sqm_debug "Keeping differentiated services code points (DSCP) from ingress."
        ipt -t mangle -A PREROUTING -i $IFACE -m mark --mark 0x00/${IPT_MASK} -g QOS_MARK_${IFACE}
    fi

    ipt -t mangle -A POSTROUTING -o $IFACE -m mark --mark 0x00/${IPT_MASK} -g QOS_MARK_${IFACE}

    # The Syn optimization was nice but fq_codel does it for us
    # ipt -t mangle -A PREROUTING -i s+ -p tcp -m tcp --tcp-flags SYN,RST,ACK SYN -j MARK --set-mark 0x01
    # Not sure if this will work. Encapsulation is a problem period

    ipt -t mangle -I PREROUTING -i vtun+ -p tcp -j MARK --set-mark 0x2/${IPT_MASK} # tcp tunnels need ordering

    # Emanating from router, do a little more optimization
    # but don't bother with it too much.

    ipt -t mangle -A OUTPUT -p udp -m multiport --ports 123,53 -j DSCP --set-dscp-class AF42

    #Not clear if the second line is needed
    #ipt -t mangle -A OUTPUT -o $IFACE -g QOS_MARK_${IFACE}

}



cake_egress()
{
    $TC qdisc add dev $IFACE root `get_stab_string` $QDISC bandwidth ${CEIL}kbit `get_cake_lla_string` ${EQDISC_OPTS}
}

egress() {

    CEIL=${UPLINK}
    
    RTRATE=$((UPLINK*10/100))
    HIGHRATE=$((UPLINK*20/100))
    MEDRATE=$((UPLINK*50/100))
    LOWRATE=$((UPLINK*15/100))
    BULKRATE=$((UPLINK*5/100))

    $TC qdisc add dev $IFACE root handle 1: `get_stab_string` hfsc default 4
    $TC class add dev $IFACE parent 1: classid 1:1 hfsc ls m2 ${CEIL}kbit ul m2 ${CEIL}kbit
    $TC class add dev $IFACE parent 1:1 classid 1:2 hfsc rt m1 "$((UPLINK*9/10))kbit" d 80ms m2 ${RTRATE}kbit
    $TC class add dev $IFACE parent 1:1 classid 1:3 hfsc ls m1 "$((UPLINK*60/100))kbit" d 80ms m2 ${HIGHRATE}kbit
    $TC class add dev $IFACE parent 1:1 classid 1:4 hfsc ls m1 "$((UPLINK*30/100))kbit" d 80ms m2 ${MEDRATE}kbit
    $TC class add dev $IFACE parent 1:1 classid 1:5 hfsc ls m1 "$((UPLINK*5/100))kbit" d 80ms m2 ${LOWRATE}kbit
    $TC class add dev $IFACE parent 1:1 classid 1:6 hfsc ls m1 "$((UPLINK*5/10))kbit" d 80ms m2 ${BULKRATE}kbit

}


cake_ingress()
{
    CAKEARGS=
    [ "$IGNORE_DSCP_INGRESS" = "1" ] && CAKEARGS="$CAKEARGS besteffort"
    $TC qdisc add dev $DEV root `get_stab_string` $QDISC bandwidth ${DOWNLINK}kbit \
        $CAKEARGS `get_cake_lla_string` ${IQDISC_OPTS}

    $IP link set dev $DEV up

    # redirect all IP packets arriving in $IFACE to $DEV

    $TC filter add dev $IFACE parent ffff: protocol all prio 10 u32 \
        match u32 0 0 flowid 1:1 action mirred egress redirect dev $DEV
}

ingress() {


    CEIL=${UPLINK}
    
    RTRATE=$((UPLINK*10/100))
    HIGHRATE=$((UPLINK*20/100))
    MEDRATE=$((UPLINK*50/100))
    LOWRATE=$((UPLINK*15/100))
    BULKRATE=$((UPLINK*5/100))

    $TC qdisc add dev $DEV root handle 1: `get_stab_string` hfsc default 4
    $TC class add dev $DEV parent 1: classid 1:1 hfsc ls m2 ${CEIL}kbit ul m2 ${CEIL}kbit
    $TC class add dev $DEV parent 1:1 classid 1:2 hfsc rt m1 "$((UPLINK*9/10))kbit" d 80ms m2 ${RTRATE}kbit
    $TC class add dev $DEV parent 1:1 classid 1:3 hfsc ls m1 "$((UPLINK*60/100))kbit" d 80ms m2 ${HIGHRATE}kbit
    $TC class add dev $DEV parent 1:1 classid 1:4 hfsc ls m1 "$((UPLINK*30/100))kbit" d 80ms m2 ${MEDRATE}kbit
    $TC class add dev $DEV parent 1:1 classid 1:5 hfsc ls m1 "$((UPLINK*5/100))kbit" d 80ms m2 ${LOWRATE}kbit
    $TC class add dev $DEV parent 1:1 classid 1:6 hfsc ls m1 "$((UPLINK*5/10))kbit" d 80ms m2 ${BULKRATE}kbit

    $IP link set dev $DEV up

    # redirect all IP packets arriving in $IFACE to $DEV

    $TC filter add dev $IFACE parent ffff: protocol all prio 10 u32 \
        match u32 0 0 flowid 1:1 action mirred egress redirect dev $DEV

}

sqm_prepare_script() {
    do_modules
    verify_qdisc "htb" || return 1
    ipt_setup
}
